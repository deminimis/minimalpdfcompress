# backend.py
import os
import sys
import subprocess
import logging
import shutil
import tempfile
from pathlib import Path
import pikepdf
import re
from PIL import Image
import zlib

from constants import ROTATION_MAP

#region: Exceptions and Helpers
class ToolNotFound(Exception): pass
class GhostscriptNotFound(ToolNotFound): pass
class CpdfNotFound(ToolNotFound): pass
class Sam2pNotFound(ToolNotFound): pass
class ProcessingError(Exception): pass

def resource_path(relative_path):
    try:
        base_path = Path(sys._MEIPASS)
    except AttributeError:
        base_path = Path(__file__).parent
    return base_path / relative_path
#endregion

#region: Tool Finders
def find_ghostscript():
    exe_name = "gswin64c.exe" if sys.platform == "win32" else "gs"
    local_bin_path = resource_path('bin') / exe_name
    if local_bin_path.exists(): return str(local_bin_path)
    raise GhostscriptNotFound("Bundled Ghostscript executable not found in 'bin' folder.")

def find_cpdf():
    exe_name = "cpdf.exe" if sys.platform == "win32" else "cpdf"
    local_bin_path = resource_path('bin') / exe_name
    if local_bin_path.exists(): return str(local_bin_path)
    raise CpdfNotFound("Bundled cpdf executable not found in 'bin' folder.")

def find_sam2p():
    exe_name = "sam2p.exe" if sys.platform == "win32" else "sam2p"
    local_bin_path = resource_path('bin') / exe_name
    if local_bin_path.exists(): return str(local_bin_path)
    raise Sam2pNotFound("sam2p executable not found in 'bin' folder.")

def find_srgb_profile():
    srgb_path = resource_path('lib/srgb.icc')
    if srgb_path.exists(): return str(srgb_path)
    raise FileNotFoundError("Could not find 'srgb.icc'. Please ensure it is in the 'lib' folder.")
#endregion

#region: Image Optimization
def optimize_image(image_stream, filter_type, sam2p_path, temp_dir):
    logging.debug(f"Optimizing image with filter: {filter_type}")
    temp_input = temp_dir / f"img_{id(image_stream)}.tmp"
    temp_output = temp_dir / f"img_{id(image_stream)}.opt"
    
    try:
        logging.debug(f"Image stream details: length={image_stream.Length}, filter={image_stream.Filter}")
        if isinstance(filter_type, pikepdf.Array) or filter_type not in ['/FlateDecode', '/DCTDecode']:
            logging.warning(f"Skipping optimization for image with invalid or array filter: {filter_type}")
            return
        
        try:
            original_data = image_stream.read_bytes()
        except Exception as e:
            logging.warning(f"Failed to read image stream: {e}. Falling back to raw stream buffer.")
            original_data = bytes(image_stream.get_raw_stream_buffer())
        
        original_size = len(original_data)
        with open(temp_input, 'wb') as f:
            f.write(original_data)
        
        compressed_data = zlib.compress(original_data, level=9)
        if len(compressed_data) < original_size * 0.9:
            image_stream.write(compressed_data, filter=pikepdf.Name("/FlateDecode"))
            return
        
        if filter_type == '/DCTDecode':
            temp_output = temp_output.with_suffix('.jpg')
            cmd = [sam2p_path, "-j:quiet", "-j:jpg", str(temp_input), str(temp_output)]
            run_command(cmd)
            if temp_output.exists():
                with open(temp_output, 'rb') as f:
                    optimized_data = f.read()
                image_stream.write(optimized_data, filter=pikepdf.Name("/DCTDecode"))
                logging.info(f"Successfully applied sam2p optimization for {temp_input}")
            else:
                logging.warning(f"No output file generated by sam2p at {temp_output}")
    
    except (FileNotFoundError, subprocess.CalledProcessError) as e:
        logging.error(f"Error during image optimization: {e}")
        raise ProcessingError(f"Image optimization failed: {e}")
    except Exception as e:
        logging.error(f"Unexpected error during image optimization: {e}", exc_info=True)
        raise ProcessingError(f"An unexpected error occurred during image optimization: {e}")

def optimize_images(pdf_path, output_path, sam2p_path):
    logging.debug(f"Starting image optimization for PDF: {pdf_path}")
    try:
        with tempfile.TemporaryDirectory() as temp_dir:
            temp_dir = Path(temp_dir)
            with pikepdf.open(pdf_path) as pdf:
                for page in pdf.pages:
                    if not page.get('/Resources') or not page['/Resources'].get('/XObject'):
                        continue
                    for xobj_name, xobj in page['/Resources']['/XObject'].items():
                        if xobj.get('/Subtype') == '/Image':
                            filter_type = xobj.get('/Filter', '/FlateDecode')
                            if filter_type in ['/FlateDecode', '/DCTDecode'] and not isinstance(filter_type, pikepdf.Array):
                                optimize_image(xobj, filter_type, sam2p_path, temp_dir)
                pdf.save(output_path)
    except Exception as e:
        logging.error(f"Failed to optimize images in PDF {pdf_path}: {e}", exc_info=True)
        raise ProcessingError(f"Image optimization failed: {e}")
#endregion

#region: Command Execution
def build_gs_command(gs_path, input_path, output_path, operation, options):
    cmd = [ gs_path, "-sDEVICE=pdfwrite", "-dCompatibilityLevel=1.4", "-dNOPAUSE", "-dBATCH", "-dQUIET", "-dSAFER",
            f"-dDownScaleFactor={options['downscale_factor']}", f"-dDownsampleType=/{options['downsample_type']}",
            f"-dSubsetFonts={'true' if options['subset_fonts'] else 'false'}", f"-dCompressFonts={'true' if options['compress_fonts'] else 'false'}" ]
    try:
        img_res = int(options['image_resolution'])
        cmd.extend([f"-dColorImageResolution={img_res}", f"-dGrayImageResolution={img_res}"])
    except (ValueError, TypeError) as e:
        logging.warning(f"Invalid image resolution: {options['image_resolution']}, error: {e}")
    if options['fast_web_view']: cmd.append("-dFastWebView=true")
    if options.get('remove_interactive', False): cmd.extend(["-dShowAnnots=false", "-dShowAcroForm=false"])
    
    preset_map = { "Compress (Screen - Smallest Size)": "/screen", "Compress (Ebook - Medium Size)": "/ebook",
                   "Compress (Printer - High Quality)": "/printer", "Compress (Prepress - Highest Quality)": "/prepress" }
    if operation in preset_map:
        cmd.extend([f"-dPDFSETTINGS={preset_map[operation]}", f"-sColorConversionStrategy={options['color_strategy']}"])
    
    cmd.extend([f"-sOutputFile={output_path}", input_path])
    logging.debug(f"Built Ghostscript command: {cmd}")
    return cmd

def build_pdfa_command(gs_path, input_path, output_path):
    pdfa_def_path_str = str(resource_path('lib/PDFA_def.ps'))
    if not Path(pdfa_def_path_str).exists():
        logging.error(f"PDFA_def.ps not found at {pdfa_def_path_str}")
        raise FileNotFoundError("Could not find 'PDFA_def.ps'. Please ensure it is in the 'lib' folder.")

    cmd = [
        gs_path,
        "-dPDFA=2",
        "-dBATCH",
        "-dNOPAUSE",
        "-dNOOUTERSAVE",
        "-sDEVICE=pdfwrite",
        "-dPDFACompatibilityPolicy=1",
        "-sColorConversionStrategy=UseDeviceIndependentColor",
        f"-sOutputFile={output_path}",
        pdfa_def_path_str,
        input_path
    ]
    logging.debug(f"Built PDF/A command: {cmd}")
    return cmd

def build_pdf_to_image_command(gs_path, input_pdf, output_dir, options):
    fmt, dpi = options.get('format', 'png'), options.get('dpi', '300')
    out_path = Path(output_dir) / f"{Path(input_pdf).stem}_%d.{fmt}"
    device_map = {'png': 'png16m', 'jpeg': 'jpeg', 'tiff': 'tiffg4'}
    cmd = [ gs_path, f"-sDEVICE={device_map.get(fmt, 'png16m')}", f"-r{dpi}", "-dNOPAUSE", "-dBATCH", "-dSAFER", f"-sOutputFile={str(out_path)}", input_pdf ]
    logging.debug(f"Built PDF to image command: {cmd}")
    return cmd

def run_command(command, check=True):
    logging.info(f"Executing command: {command}")
    try:
        kwargs = { 'stdin': subprocess.DEVNULL, 'check': check, 'capture_output': True, 'text': True, 'encoding': 'utf-8', 'errors': 'ignore' }
        if sys.platform == "win32": kwargs['creationflags'] = subprocess.CREATE_NO_WINDOW
        result = subprocess.run(command, **kwargs)
        if result.stderr and check and "warning" not in result.stderr.lower():
            logging.warning(f"Command produced stderr: {result.stderr[:200]}...")
    except subprocess.CalledProcessError as e:
        logging.error(f"Command failed: {e.stderr}")
        raise ProcessingError(f"Tool failed: {e.stderr[:200]}...")
    except FileNotFoundError as e:
        logging.error(f"Command not found: {e}")
        raise ProcessingError(f"Command not found: {e}.")
    except Exception as e:
        logging.error(f"Unexpected error: {e}")
        raise ProcessingError(str(e))
#endregion

#region: Preview Generation
def generate_preview_image(gs_path, cpdf_path, pdf_in, operation, options):
    if not Path(pdf_in).exists():
        raise FileNotFoundError("Input PDF for preview not found.")

    with tempfile.TemporaryDirectory() as temp_dir:
        temp_dir_path = Path(temp_dir)
        first_page_pdf = temp_dir_path / "first_page.pdf"
        modified_pdf = temp_dir_path / "modified.pdf"
        preview_image_path = temp_dir_path / "preview.png"

        try:
            with pikepdf.open(pdf_in) as pdf:
                if not pdf.pages:
                    raise ProcessingError("PDF has no pages to preview.")
                with pikepdf.Pdf.new() as dst:
                    dst.pages.append(pdf.pages[0])
                    dst.save(first_page_pdf)
        except Exception as e:
            logging.error(f"Failed to extract first page for preview: {e}")
            raise ProcessingError(f"Failed to read PDF for preview: {e}")

        if operation == 'rotate':
            try:
                with pikepdf.open(first_page_pdf) as pdf:
                    pdf.pages[0].rotate(options.get('angle', 0), relative=True)
                    pdf.save(modified_pdf)
            except Exception as e:
                logging.error(f"Failed to apply rotation for preview: {e}")
                raise ProcessingError(f"Failed to rotate for preview: {e}")
        
        elif operation == 'stamp':
            try:
                stamp_opts = options['stamp_opts']
                mode_opts = options['mode_opts']
                mode = options['mode']
                
                cmd = [cpdf_path]
                pos_map = { "Center": ["-center"], "Bottom-Left": ["-bottomleft", "10"], "Bottom-Right": ["-bottomright", "10"] }
                pos_cmd = pos_map.get(stamp_opts['pos'], ["-center"])

                if mode == "Image":
                    image_path = mode_opts.get('image_path')
                    if not image_path or not Path(image_path).exists():
                        raise FileNotFoundError("Stamp image file not found for preview.")
                    
                    with tempfile.NamedTemporaryFile(suffix=".pdf", delete=False, dir=temp_dir) as temp_stamp_pdf_file:
                        temp_stamp_pdf_path = temp_stamp_pdf_file.name
                    
                    with Image.open(image_path) as img:
                        width, height = img.size
                        if new_w_str := mode_opts.get('width'): width = int(new_w_str)
                        if new_h_str := mode_opts.get('height'): height = int(new_h_str)
                        if (width, height) != img.size: img = img.resize((width, height), Image.LANCZOS)
                        if stamp_opts['opacity'] < 1.0:
                            if img.mode != 'RGBA': img = img.convert('RGBA')
                            alpha = img.split()[3]
                            alpha = alpha.point(lambda p: p * stamp_opts['opacity'])
                            img.putalpha(alpha)
                        img.save(temp_stamp_pdf_path, "PDF", resolution=100.0)
                    
                    cmd.extend([str(first_page_pdf), "-stamp-on" if stamp_opts['on_top'] else "-stamp-under", temp_stamp_pdf_path])
                else:
                    text_to_stamp = mode_opts['text']
                    cmd.extend([str(first_page_pdf), "-add-text", text_to_stamp.strip(), "-font", mode_opts['font'],
                                "-font-size", str(mode_opts['size']), "-color", mode_opts['color']])
                    if (bates_start := mode_opts.get('bates_start')):
                        cmd.extend(["-bates", bates_start])
                    cmd.extend(["-opacity", str(stamp_opts['opacity'])])
                    if not stamp_opts['on_top']: cmd.append("-underneath")

                cmd.extend(pos_cmd)
                cmd.extend(["-o", str(modified_pdf)])
                run_command(cmd)
            except Exception as e:
                logging.error(f"Failed to apply stamp for preview: {e}", exc_info=True)
                raise ProcessingError(f"Failed to create stamp preview: {e}")
        else:
            shutil.copy(first_page_pdf, modified_pdf)

        try:
            render_cmd = build_pdf_to_image_command(gs_path, str(modified_pdf), temp_dir_path, {'format': 'png', 'dpi': '150'})
            
            output_file_arg = f'-sOutputFile={preview_image_path}'
            output_arg_index = -1
            for i, arg in enumerate(render_cmd):
                if arg.startswith('-sOutputFile='):
                    output_arg_index = i
                    break
            
            if output_arg_index != -1:
                render_cmd[output_arg_index] = output_file_arg
            else:
                raise ProcessingError("Could not find -sOutputFile in Ghostscript command for preview.")

            run_command(render_cmd)
        except Exception as e:
            logging.error(f"Failed to render preview image with Ghostscript: {e}")
            raise ProcessingError(f"Failed to render preview: {e}")
        
        if not preview_image_path.exists():
            raise ProcessingError("Preview image was not generated.")
        
        with open(preview_image_path, 'rb') as f:
            return f.read()
#endregion

#region: Final Processing & Page Logic
def apply_final_processing(file_path, options, cpdf_path):
    use_any_cpdf = (options.get('use_cpdf_squeeze', False) or options.get('darken_text', False) or
                    options.get('user_password') or options.get('owner_password'))
    if use_any_cpdf and cpdf_path:
        logging.info(f"Applying cpdf processing to {file_path}")
        with tempfile.NamedTemporaryFile(suffix=".pdf", delete=False) as temp_cpdf_out:
            temp_path = str(temp_cpdf_out.name)
        try:
            cmd = [cpdf_path]
            if options.get('use_fast_processing', False): cmd.append("-fast")
            cmd.append(str(file_path))
            if options.get('use_cpdf_squeeze', False): cmd.extend(["AND", "-squeeze"])
            if options.get('darken_text', False): cmd.extend(["AND", "-blacktext"])

            user_pass, owner_pass = options.get('user_password'), options.get('owner_password')
            if user_pass or owner_pass:
                cmd.extend(["AND", "-encrypt", "AES", user_pass if user_pass else '""', owner_pass if owner_pass else '""'])

            cmd.extend(["-o", temp_path])
            run_command(cmd)
            shutil.move(temp_path, file_path)
        finally:
            if os.path.exists(temp_path): os.remove(temp_path)
    else:
        logging.info(f"Applying Pikepdf processing to {file_path}")
        try:
            pikepdf.settings.set_flate_compression_level(options.get('pikepdf_compression_level', 6))
            if (dp_str := options.get('decimal_precision', 'Default')).isdigit():
                pikepdf.settings.set_decimal_precision(int(dp_str))

            with pikepdf.open(file_path, allow_overwriting_input=True) as pdf:
                rotation_str = options.get('rotation', 'No Rotation')
                angle = ROTATION_MAP.get(rotation_str, 0)
                
                if angle != 0:
                    for page in pdf.pages: page.rotate(angle, relative=True)
                if options.get('strip_metadata', False):
                    with pdf.open_metadata(set_pikepdf_as_editor=False) as meta:
                        for key in list(meta.keys()): del meta[key]

                pdf.save(file_path, object_stream_mode=pikepdf.ObjectStreamMode.generate, compress_streams=True)
        except Exception as e:
            logging.error(f"Pikepdf processing failed: {e}")
            raise ProcessingError(f"Final processing step failed: {e}")

def parse_page_ranges(page_string, max_pages):
    indices = set()
    if not page_string.strip(): return []
    page_string = re.sub(r'\bend\b', str(max_pages), page_string, flags=re.IGNORECASE)
    for part in page_string.split(','):
        part = part.strip()
        if not part: continue
        if '-' in part:
            start, end = part.split('-', 1)
            start = 1 if start.strip() == '' else int(start)
            end = max_pages if end.strip() == '' else int(end)
            indices.update(range(start - 1, end))
        else: indices.add(int(part) - 1)
    return sorted(list(indices), reverse=True)
#endregion

#region: Main Task Runners
def _process_single_file(input_file, output_file, params, sam2p_path, status_var, progress_var):
    with tempfile.NamedTemporaryFile(suffix=".pdf", delete=False) as gs_temp_out:
        gs_temp_path = str(gs_temp_out.name)
    
    try:
        # Step 1: Run Ghostscript for initial compression
        cmd = build_gs_command(params['gs_path'], str(input_file), gs_temp_path, params['operation'], params['options'])
        status_var.set(f"Compressing {Path(input_file).name}...")
        progress_var['value'] = 20
        run_command(cmd)
        progress_var['value'] = 50
        
        # Determine the path for the next processing step
        temp_final_path = output_file
        if params['overwrite']:
            parent_dir = Path(input_file).parent
            temp_final_path = parent_dir / f"temp_{os.urandom(8).hex()}_{Path(input_file).name}"

        # Step 2: Optimize images if requested
        if sam2p_path and params.get('optimize_images', False):
            status_var.set("Optimizing images...")
            optimize_images(gs_temp_path, temp_final_path, sam2p_path)
        else:
            shutil.move(gs_temp_path, temp_final_path)
        
        progress_var['value'] = 80
        
        # Step 3: Apply final processing (Pikepdf/cpdf)
        status_var.set("Applying final options...")
        apply_final_processing(temp_final_path, params['options'], params['cpdf_path'])
        
        # Step 4: If overwriting, replace the original file
        if params['overwrite']:
            shutil.move(temp_final_path, input_file)

        progress_var['value'] = 100

    finally:
        # Cleanup temporary files
        if os.path.exists(gs_temp_path):
            os.remove(gs_temp_path)
        if 'temp_final_path' in locals() and os.path.exists(temp_final_path) and params['overwrite']:
            os.remove(temp_final_path)

def run_conversion_task(params, is_folder, status_var, progress_var, overall_progress_var, cb):
    try:
        sam2p_path = find_sam2p() if params.get('optimize_images', False) else None
        input_path = Path(params['input_path'])
        output_path = Path(params['output_path'])
        
        if is_folder:
            output_path.mkdir(parents=True, exist_ok=True)
            pdf_files = sorted(list(input_path.glob("*.pdf")))
            total_files = len(pdf_files)
            if total_files == 0:
                raise ProcessingError(f"No PDF files found in '{input_path}'")
            
            for i, pdf_file in enumerate(pdf_files):
                status_var.set(f"Processing file {i+1} of {total_files}...")
                output_file = output_path / pdf_file.name
                _process_single_file(pdf_file, output_file, params, sam2p_path, status_var, progress_var)
                overall_progress_var['value'] = ((i + 1) / total_files) * 100
        else:
            status_var.set(f"Processing file {input_path.name}...")
            _process_single_file(input_path, output_path, params, sam2p_path, status_var, progress_var)
            overall_progress_var['value'] = 100
        
        cb("Processing complete.")
    except (ToolNotFound, ProcessingError, FileNotFoundError, ValueError) as e:
        logging.error(f"Task failed: {e}")
        cb(f"Error: {e}")
    except Exception as e:
        logging.error(f"An unexpected error occurred in conversion task: {e}", exc_info=True)
        cb(f"An unexpected error occurred: {e}")

def run_merge_task(file_list, output_path, status_var, progress_var, overall_progress_var, cb):
    try:
        progress_var['value'] = 0
        overall_progress_var['value'] = 0
        with pikepdf.Pdf.new() as pdf:
            total_files = len(file_list)
            if total_files == 0:
                raise ProcessingError("No files selected to merge.")
            for i, file_path in enumerate(file_list):
                status_var.set(f"Adding {Path(file_path).name} ({i+1}/{total_files})")
                with pikepdf.open(file_path) as src:
                    pdf.pages.extend(src.pages)
                progress_var['value'] = ((i + 1) / total_files) * 100
            
            status_var.set("Saving merged file...")
            pdf.save(output_path)
            overall_progress_var['value'] = 100
        cb("Merge complete.")
    except Exception as e:
        logging.error(f"Merge task failed: {e}")
        cb(f"Error: {e}")

def run_split_task(input_path, output_dir, mode, value, status_var, progress_var, overall_progress_var, cb):
    try:
        status_var.set("Opening PDF..."); progress_var['value'] = 10; overall_progress_var['value'] = 0
        p_in = Path(input_path)
        with pikepdf.open(p_in) as pdf:
            total = len(pdf.pages)
            if mode == "Split to Single Pages":
                for i, page in enumerate(pdf.pages):
                    status_var.set(f"Saving page {i+1}/{total}")
                    progress_val = ((i + 1) / total) * 100
                    progress_var['value'] = progress_val
                    overall_progress_var['value'] = progress_val
                    with pikepdf.Pdf.new() as dst:
                        dst.pages.append(page)
                        dst.save(Path(output_dir) / f"{p_in.stem}_page_{i+1}.pdf")
            elif mode == "Split Every N Pages":
                n = int(value)
                if n <= 0: raise ValueError("Number of pages must be positive.")
                for i in range(0, total, n):
                    status_var.set(f"Saving pages {i+1}-{min(i+n, total)}")
                    progress_val = (min(i + n, total) / total) * 100
                    progress_var['value'] = progress_val
                    overall_progress_var['value'] = progress_val
                    with pikepdf.Pdf.new() as dst:
                        dst.pages.extend(pdf.pages[i:i+n])
                        dst.save(Path(output_dir) / f"{p_in.stem}_pages_{i+1}-{i+n}.pdf")
            elif mode == "Custom Range(s)":
                indices = parse_page_ranges(value, total)
                status_var.set(f"Extracting {len(indices)} pages...")
                with pikepdf.Pdf.new() as dst:
                    for i, page_index in enumerate(sorted([i for i in indices if i < total])):
                        dst.pages.append(pdf.pages[page_index])
                        progress_val = ((i+1)/len(indices)) * 100
                        progress_var['value'] = progress_val
                        overall_progress_var['value'] = progress_val
                dst.save(Path(output_dir) / f"{p_in.stem}_custom_range.pdf")
            else:
                 raise ProcessingError(f"Unknown split mode: {mode}")
        cb("Splitting complete.")
    except Exception as e:
        logging.error(f"Split task failed: {e}")
        cb(f"Error: {e}")

def run_delete_pages_task(pdf_in, pdf_out, page_range, status_var, progress_var, overall_progress_var, cb):
    try:
        status_var.set("Opening PDF..."); progress_var['value'] = 10; overall_progress_var['value'] = 10
        with pikepdf.open(pdf_in) as pdf:
            indices_to_delete = parse_page_ranges(page_range, len(pdf.pages))
            if not indices_to_delete: 
                raise ProcessingError("No valid pages specified for deletion.")
            status_var.set(f"Deleting {len(indices_to_delete)} page(s)...")
            progress_var['value'] = 50; overall_progress_var['value'] = 50
            for i in indices_to_delete:
                del pdf.pages[i]
            pdf.save(pdf_out)
            progress_var['value'] = 100; overall_progress_var['value'] = 100
        cb("Page deletion completed.")
    except Exception as e:
        logging.error(f"Delete pages task failed: {e}")
        cb(f"Error: {e}")

def run_rotate_task(pdf_in, pdf_out, angle, status_var, progress_var, overall_progress_var, cb):
    try:
        status_var.set("Opening PDF..."); progress_var['value'] = 20; overall_progress_var['value'] = 20
        with pikepdf.open(pdf_in) as pdf:
            status_var.set(f"Rotating all pages by {angle} degrees..."); progress_var['value'] = 50; overall_progress_var['value'] = 50
            for page in pdf.pages: page.rotate(angle, relative=True)
            pdf.save(pdf_out)
            progress_var['value'] = 100; overall_progress_var['value'] = 100
        cb("Rotation complete.")
    except Exception as e:
        logging.error(f"Rotate task failed: {e}")
        cb(f"Error: {e}")

def run_stamp_task(pdf_in, pdf_out, stamp_opts, cpdf_path, status_var, progress_var, overall_progress_var, cb, mode, mode_opts):
    temp_stamp_pdf = None
    try:
        status_var.set("Preparing stamp..."); progress_var['value'] = 25; overall_progress_var['value'] = 25
        pos_map = { "Center": ["-center"], "Bottom-Left": ["-bottomleft", "10"], "Bottom-Right": ["-bottomright", "10"] }
        pos_cmd = pos_map.get(stamp_opts['pos'], ["-center"])
        cmd = [cpdf_path]
        if mode == "Image":
            with tempfile.NamedTemporaryFile(suffix=".pdf", delete=False) as temp_pdf_file:
                temp_stamp_pdf = temp_pdf_file.name

            with Image.open(mode_opts['image_path']) as img:
                width, height = img.size
                if new_w_str := mode_opts.get('width'): width = int(new_w_str)
                if new_h_str := mode_opts.get('height'): height = int(new_h_str)
                if (width, height) != img.size: img = img.resize((width, height), Image.LANCZOS)
                if stamp_opts['opacity'] < 1.0:
                    if img.mode != 'RGBA': img = img.convert('RGBA')
                    alpha = img.split()[3]
                    alpha = alpha.point(lambda p: p * stamp_opts['opacity'])
                    img.putalpha(alpha)
                img.save(temp_stamp_pdf, "PDF", resolution=100.0)

            cmd.extend([pdf_in, "-stamp-on" if stamp_opts['on_top'] else "-stamp-under", temp_stamp_pdf])
        else:
            text_to_stamp = mode_opts['text']
            cmd.extend([pdf_in, "-add-text", text_to_stamp.strip(), "-font", mode_opts['font'],
                        "-font-size", str(mode_opts['size']), "-color", mode_opts['color']])
            if (bates_start := mode_opts.get('bates_start')): cmd.extend(["-bates", bates_start])
            cmd.extend(["-opacity", str(stamp_opts['opacity'])])
            if not stamp_opts['on_top']: cmd.append("-underneath")

        cmd.extend(pos_cmd)
        cmd.extend(["-o", pdf_out])
        status_var.set("Applying stamp..."); progress_var['value'] = 75; overall_progress_var['value'] = 75
        run_command(cmd)
        progress_var['value'] = 100; overall_progress_var['value'] = 100
        cb("Stamping complete.")
    except Exception as e:
        logging.error(f"Stamp task failed: {e}")
        cb(f"Error: {e}")
    finally:
        if temp_stamp_pdf and os.path.exists(temp_stamp_pdf):
            os.remove(temp_stamp_pdf)

def run_metadata_task(task_type, pdf_path, cpdf_path, metadata_dict=None):
    if task_type == 'load':
        cmd = [cpdf_path, "-info", pdf_path]
        proc = subprocess.run(cmd, capture_output=True, text=True, encoding='utf-8', errors='ignore')
        if proc.returncode != 0: raise ProcessingError(f"cpdf failed to read info: {proc.stderr[:200]}")
        info = {}
        for line in proc.stdout.splitlines():
            if ':' in line:
                key, val = line.split(':', 1)
                key = key.strip().lower()
                if key in ['title', 'author', 'subject', 'keywords']: info[key] = val.strip()
        return info
    elif task_type == 'save':
        with tempfile.NamedTemporaryFile(suffix=".pdf", delete=False) as temp_out:
            temp_path = temp_out.name
        try:
            cmd = [cpdf_path, pdf_path]
            first_op = True
            for key, value in metadata_dict.items():
                if value:
                    if not first_op: cmd.append("AND")
                    cmd.extend([f"-set-{key}", value]); first_op = False
            if first_op: return 
            cmd.extend(["-o", temp_path])
            run_command(cmd)
            shutil.move(temp_path, pdf_path)
        finally:
            if os.path.exists(temp_path): os.remove(temp_path)

def run_remove_open_action_task(pdf_in, cpdf_path, status_var, progress_var, overall_progress_var, cb):
    try:
        status_var.set("Removing opening action..."); progress_var['value'] = 50; overall_progress_var['value'] = 50
        with tempfile.NamedTemporaryFile(suffix=".pdf", delete=False) as temp_out:
            temp_path = temp_out.name
        cmd = [cpdf_path, pdf_in, "-remove-dict-entry", "/OpenAction", "-o", temp_path]
        run_command(cmd)
        shutil.move(temp_path, pdf_in) 
        progress_var['value'] = 100; overall_progress_var['value'] = 100
        cb("Opening action removed.")
    except Exception as e:
        logging.error(f"Remove open action task failed: {e}")
        cb(f"Error: {e}")
#endregion